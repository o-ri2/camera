<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>화질 저하 효과</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #ffffff;
            overflow: hidden;
        }

        .container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: #000;
            overflow: hidden;
        }

        #mainCanvas {
            flex: 1;
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            image-rendering: pixelated;
            transition: filter 0.3s;
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="canvas-container">
            <canvas id="mainCanvas"></canvas>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');

        // 자동 복원 기본 설정
        const AUTO_RESET_TIME = 10; // 기본 10초
        const AUTO_RESET_ENABLED = true; // 기본 활성화

        let originalImage = null;
        let currentImage = null;
        let quality = 100;
        let scaleFactor = 1.0;
        let degradationCount = 0;
        const MAX_DEGRADATION_STEPS = 500; // 최대 500단계
        let autoResetTimer = null;
        let autoResetInterval = null;
        let remainingTime = 0;
        
        // WebSocket 연결
        let ws = null;

        // Canvas 크기 설정 (21:9 비율에 맞게)
        function resizeCanvas() {
            const targetAspectRatio = 21 / 9; // 21:9 비율
            const windowAspectRatio = window.innerWidth / window.innerHeight;
            
            let canvasWidth, canvasHeight;
            
            if (windowAspectRatio > targetAspectRatio) {
                // 화면이 21:9보다 넓으면 높이를 기준으로
                canvasHeight = window.innerHeight;
                canvasWidth = canvasHeight * targetAspectRatio;
            } else {
                // 화면이 21:9보다 좁거나 같으면 너비를 기준으로
                canvasWidth = window.innerWidth;
                canvasHeight = canvasWidth / targetAspectRatio;
            }
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            if (currentImage) {
                drawImage();
            }
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // 이미지 로드
        function loadImage(url) {
            const img = new Image();
            
            img.onload = function() {
                originalImage = img;
                currentImage = img;
                quality = 100;
                scaleFactor = 1.0;
                degradationCount = 0;
                stopAutoReset();
                updateInfo();
                drawImage();
            };
            
            img.onerror = function() {
                alert('이미지를 로드할 수 없습니다. img/123.png 파일을 확인해주세요.');
            };
            
            img.src = url;
        }

        // 이미지 그리기
        function drawImage() {
            if (!currentImage) return;
            
            // 임시 캔버스에 저해상도로 그리기
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            // 저해상도 크기 계산
            const scaledWidth = Math.max(1, Math.floor(canvas.width * scaleFactor));
            const scaledHeight = Math.max(1, Math.floor(canvas.height * scaleFactor));
            
            tempCanvas.width = scaledWidth;
            tempCanvas.height = scaledHeight;
            
            // 21:9 비율에 맞게 이미지를 꽉 채워서 그리기
            const targetAspect = 21 / 9; // 21:9 비율
            const imgAspect = currentImage.width / currentImage.height;
            
            let drawX = 0;
            let drawY = 0;
            let drawWidth = scaledWidth;
            let drawHeight = scaledHeight;
            let sourceX = 0;
            let sourceY = 0;
            let sourceWidth = currentImage.width;
            let sourceHeight = currentImage.height;
            
            // 이미지가 21:9보다 넓으면 좌우를 잘라서, 좁으면 상하를 잘라서 21:9 비율로 맞춤
            if (imgAspect > targetAspect) {
                // 이미지가 더 넓으면 좌우를 잘라서 21:9로 맞춤
                sourceWidth = currentImage.height * targetAspect;
                sourceX = (currentImage.width - sourceWidth) / 2;
            } else {
                // 이미지가 더 좁으면 상하를 잘라서 21:9로 맞춤
                sourceHeight = currentImage.width / targetAspect;
                sourceY = (currentImage.height - sourceHeight) / 2;
            }
            
            // 이미지 스무딩 비활성화 (픽셀화 효과)
            tempCtx.imageSmoothingEnabled = false;
            tempCtx.drawImage(
                currentImage,
                sourceX, sourceY, sourceWidth, sourceHeight, // 소스 영역
                drawX, drawY, drawWidth, drawHeight // 대상 영역
            );
            
            // 메인 캔버스에 확대하여 그리기
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);
            
            // 단계별 효과 적용
            // 초기 단계: 약한 블러
            if (degradationCount > 10) {
                const blurAmount = Math.min((degradationCount - 10) * 0.1, 5);
                if (blurAmount > 0) {
                    ctx.filter = `blur(${blurAmount}px)`;
                    ctx.drawImage(canvas, 0, 0);
                    ctx.filter = 'none';
                }
            }
            
            // 중간 단계: 색상 감소 효과
            if (degradationCount > 30) {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const colorReduction = Math.min((degradationCount - 30) * 2, 50);
                
                for (let i = 0; i < data.length; i += 4) {
                    // 색상 비트 감소 (포스터화 효과)
                    const factor = Math.floor(colorReduction / 10);
                    if (factor > 0) {
                        const levels = Math.pow(2, Math.max(1, 8 - factor));
                        data[i] = Math.floor(data[i] / (256 / levels)) * (256 / levels);     // R
                        data[i + 1] = Math.floor(data[i + 1] / (256 / levels)) * (256 / levels); // G
                        data[i + 2] = Math.floor(data[i + 2] / (256 / levels)) * (256 / levels); // B
                    }
                }
                ctx.putImageData(imageData, 0, 0);
            }
            
            // 고급 단계: 노이즈 추가
            if (degradationCount > 60) {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const noiseAmount = Math.min((degradationCount - 60) * 0.5, 20);
                
                for (let i = 0; i < data.length; i += 4) {
                    const noise = (Math.random() - 0.5) * noiseAmount;
                    data[i] = Math.max(0, Math.min(255, data[i] + noise));         // R
                    data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise)); // G
                    data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise)); // B
                }
                ctx.putImageData(imageData, 0, 0);
            }
        }

        // 화질 저하
        function degradeQuality() {
            if (!originalImage) {
                alert('먼저 이미지를 로드해주세요.');
                return;
            }
            
            if (degradationCount >= MAX_DEGRADATION_STEPS) {
                alert(`최대 화질 저하 단계(${MAX_DEGRADATION_STEPS}단계)에 도달했습니다.`);
                return;
            }
            
            // 자동 복원이 진행 중이면 중지
            if (autoResetInterval) {
                stopAutoReset();
            }
            
            degradationCount++;
            
            // 지수적 감소 곡선을 사용하여 매우 세밀한 단계별 감소
            // 500단계에 걸쳐 1.0에서 0.01까지 부드럽게 감소
            // 공식: scaleFactor = e^(-k * degradationCount)
            // k 값을 조정하여 원하는 감소 속도 설정
            const k = 0.009; // 500단계에 맞게 조정
            scaleFactor = Math.max(0.01, Math.exp(-k * degradationCount));
            
            // 품질 계산 (100%에서 1%까지, 500단계에 맞게 조정)
            quality = Math.max(1, 100 - (degradationCount * 0.198));
            
            // 자동 복원이 활성화되어 있으면 타이머 시작/리셋
            if (AUTO_RESET_ENABLED) {
                startAutoResetTimer();
            }
            
            updateInfo();
            drawImage();
        }

        // 초기화
        function reset() {
            if (!originalImage) return;
            
            currentImage = originalImage;
            quality = 100;
            scaleFactor = 1.0;
            degradationCount = 0;
            stopAutoReset(); // 초기화 시 타이머도 중지
            updateInfo();
            drawImage();
        }

        // 정보 업데이트
        function updateInfo() {
            // UI 요소가 제거되었으므로 정보 업데이트 불필요
        }

        // 화질 1단계 복구
        function restoreOneStep() {
            if (!originalImage || degradationCount <= 0) {
                return;
            }
            
            degradationCount--;
            
            // 지수적 감소 곡선을 역으로 계산하여 복구
            const k = 0.009;
            scaleFactor = Math.max(0.01, Math.exp(-k * degradationCount));
            
            // 품질 계산
            quality = Math.max(1, 100 - (degradationCount * 0.198));
            
            updateInfo();
            drawImage();
            
            // 완전히 복구되면 타이머 중지
            if (degradationCount <= 0) {
                stopAutoReset();
            }
        }

        // 자동 복원 타이머 시작/리셋 (마지막 클릭 이후로)
        function startAutoResetTimer() {
            if (!AUTO_RESET_ENABLED) {
                return;
            }
            
            const time = AUTO_RESET_TIME;
            if (!time || time < 1) {
                return;
            }
            
            if (!originalImage) {
                return;
            }
            
            // 기존 타이머가 있으면 정리하고 새로 시작
            if (autoResetInterval) {
                clearInterval(autoResetInterval);
                autoResetInterval = null;
            }
            
            remainingTime = time;
            
            // 1초마다 업데이트
            autoResetInterval = setInterval(() => {
                remainingTime--;
                
                if (remainingTime <= 0) {
                    // 1단계 복구
                    restoreOneStep();
                    
                    // 아직 복구할 단계가 남아있으면 타이머 재시작
                    if (degradationCount > 0 && AUTO_RESET_ENABLED) {
                        remainingTime = time;
                    } else {
                        stopAutoReset();
                    }
                }
            }, 1000);
        }

        // 자동 복원 중지
        function stopAutoReset() {
            if (autoResetInterval) {
                clearInterval(autoResetInterval);
                autoResetInterval = null;
            }
            
            remainingTime = 0;
        }

        // WebSocket 연결 설정
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = window.location.host;
            const wsUrl = `${protocol}//${host}`;
            
            console.log('WebSocket URL:', wsUrl);
            ws = new WebSocket(wsUrl);
            
            ws.onopen = function() {
                console.log('WebSocket 연결됨');
                
                // 작가로 등록
                ws.send(JSON.stringify({
                    type: 'register',
                    role: 'artist'
                }));
            };
            
            ws.onmessage = function(event) {
                const data = JSON.parse(event.data);
                console.log('받은 메시지:', data);
                
                if (data.type === 'button_click') {
                    // site-b에서 버튼 클릭 시 화질 저하
                    degradeQuality();
                }
            };
            
            ws.onerror = function(error) {
                console.error('WebSocket 에러:', error);
            };
            
            ws.onclose = function() {
                console.log('WebSocket 연결 종료');
                
                // 5초 후 재연결 시도
                setTimeout(connectWebSocket, 5000);
            };
        }

        // 페이지 로드 시 이미지 자동 로드 및 WebSocket 연결
        window.addEventListener('load', () => {
            loadImage('img/123.png');
            connectWebSocket();
        });
        
        // 페이지 언로드 시 정리
        window.addEventListener('beforeunload', function() {
            if (ws) {
                ws.close();
            }
        });
    </script>
</body>
</html>
