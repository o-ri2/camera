<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>nature</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100vw;
            height: 100vh;
        }
        
        .image-container {
            position: relative;
            width: 1920px;
            height: 1080px;
            max-width: 100vw;
            max-height: 100vh;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .image-wrapper {
            position: relative;
            width: 1920px;
            height: 1080px;
        }
        
        #baseImage {
            display: block;
            width: 1920px;
            height: 1080px;
            object-fit: cover; /* 1920x1080 영역을 완전히 채우도록 */
        }
        
        #pixelCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 1920px;
            height: 1080px;
            pointer-events: none;
        }
        
        /* 페이드인 효과를 위한 캔버스 오버레이 */
        .pixel-fade {
            position: absolute;
            pointer-events: none;
            animation: pixelFadeIn 0.3s ease-in forwards;
        }
        
        @keyframes pixelFadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        
        
        /* 하트 카운터 스타일 - 인스타그램 스타일 */
        .heart-counter {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(8px);
            padding: 6px 12px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 6px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }
        
        .heart-icon {
            font-size: 16px;
            color: #ff3040;
            line-height: 1;
        }
        
        .heart-count {
            font-size: 14px;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.95);
            letter-spacing: 0.3px;
        }
        
        /* 카운터 증가 애니메이션 - 미묘하게 */
        .heart-counter.pulse {
            animation: counterPulse 0.2s ease-out;
        }
        
        @keyframes counterPulse {
            0% {
                transform: translateX(-50%) scale(1);
            }
            50% {
                transform: translateX(-50%) scale(1.05);
            }
            100% {
                transform: translateX(-50%) scale(1);
            }
        }
        
    </style>
</head>
<body>
    <div class="image-container">
        <div class="image-wrapper">
            <img id="baseImage" src="image/1.png" alt="Base Image">
            <canvas id="pixelCanvas"></canvas>
        </div>
    </div>
    
    <!-- 하트 카운터 -->
    <div class="heart-counter">
        <span class="heart-icon">♥</span>
        <span class="heart-count" id="heartCount">0</span>
    </div>

    <script>
        let ws = null;
        let heartCount = 0;
        
        const baseImage = document.getElementById('baseImage');
        const canvas = document.getElementById('pixelCanvas');
        const ctx = canvas.getContext('2d');
        const heartCountElement = document.getElementById('heartCount');
        const heartCounterContainer = document.querySelector('.heart-counter');
        
        let secondImage = new Image();
        let imageLoaded = false;
        let revealedPixels = new Set(); // 이미 드러난 픽셀 위치 저장 (원본 이미지 좌표 기준: "x,y")
        
        // 1920x1080 고정이므로 스케일 계산 불필요
        
        // 2.png 로드
        secondImage.src = 'image/2.png';
        secondImage.onload = function() {
            imageLoaded = true;
            // 기존에 드러난 픽셀들 다시 그리기
            redrawCanvas();
            console.log('2.png 로드 완료');
        };
        
        // 1.png 로드 완료 시 캔버스 크기 설정
        baseImage.onload = function() {
            // 1920x1080 고정 크기
            canvas.width = 1920;
            canvas.height = 1080;
            
            // 캔버스 렌더링 품질 설정
            ctx.imageSmoothingEnabled = false; // 픽셀 아트 스타일 유지
            
            console.log('1.png 로드 완료, 캔버스 크기: 1920x1080');
        };
        
        // 하트 카운터 업데이트 함수
        function updateHeartCount(count = 1) {
            heartCount += count;
            heartCountElement.textContent = heartCount.toLocaleString();
            
            // 펄스 애니메이션 추가
            heartCounterContainer.classList.remove('pulse');
            void heartCounterContainer.offsetWidth;
            heartCounterContainer.classList.add('pulse');
            
            setTimeout(() => {
                heartCounterContainer.classList.remove('pulse');
            }, 200);
        }
        
        // WebSocket URL 자동 감지
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const host = window.location.host;
        const wsUrl = `${protocol}//${host}`;
        
        console.log('WebSocket URL:', wsUrl);
        
        // WebSocket 연결 설정
        function connectWebSocket() {
            ws = new WebSocket(wsUrl);
            
            ws.onopen = function() {
                console.log('WebSocket 연결됨');
                
                // 작가로 등록
                ws.send(JSON.stringify({
                    type: 'register',
                    role: 'artist'
                }));
            };
            
            ws.onmessage = function(event) {
                const data = JSON.parse(event.data);
                console.log('받은 메시지:', data);
                
                if (data.type === 'button_click') {
                    handleButtonClick(data.button);
                } else if (data.type === 'viewer_count') {
                    updateViewerCount(data.count);
                }
            };
            
            ws.onerror = function(error) {
                console.error('WebSocket 에러:', error);
            };
            
            ws.onclose = function() {
                console.log('WebSocket 연결 종료');
                
                // 5초 후 재연결 시도
                setTimeout(connectWebSocket, 5000);
            };
        }
        
        // 관람객 수 업데이트
        function updateViewerCount(count) {
            console.log(`현재 관람객: ${count}명`);
        }
        
        // 캔버스 다시 그리기 함수
        function redrawCanvas() {
            if (!imageLoaded) return;
            
            // 캔버스 초기화
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 모든 드러난 픽셀 다시 그리기
            const pixelSize = 10;
            
            // 렌더링 품질 설정
            ctx.imageSmoothingEnabled = false;
            
            revealedPixels.forEach(key => {
                const [x, y] = key.split(',').map(Number);
                const sourceX = x * pixelSize;
                const sourceY = y * pixelSize;
                const destX = x * pixelSize;
                const destY = y * pixelSize;
                
                ctx.drawImage(
                    secondImage,
                    sourceX, sourceY, pixelSize, pixelSize,  // 소스 이미지 영역 (원본 크기)
                    destX, destY, pixelSize, pixelSize  // 캔버스에 그릴 위치와 크기 (1920x1080 고정)
                );
            });
        }
        
        // 2.png의 랜덤 픽셀 하나를 드러내기 (페이드인 효과 포함)
        function revealPixel() {
            if (!imageLoaded) {
                console.log('2.png가 아직 로드되지 않았습니다.');
                return false;
            }
            
            const pixelSize = 10; // 원본 이미지 기준 10x10 픽셀 블록
            const cols = Math.floor(1920 / pixelSize); // 192
            const rows = Math.floor(1080 / pixelSize); // 108
            const totalPixels = cols * rows;
            
            // 모든 픽셀이 드러났는지 확인
            if (revealedPixels.size >= totalPixels) {
                console.log('모든 픽셀이 이미 드러났습니다!');
                return false;
            }
            
            // 아직 드러나지 않은 랜덤 위치 찾기
            let x, y, key;
            let attempts = 0;
            do {
                x = Math.floor(Math.random() * cols);
                y = Math.floor(Math.random() * rows);
                key = `${x},${y}`;
                attempts++;
                if (attempts > 1000) {
                    console.log('픽셀 선택 실패 - 너무 많은 시도');
                    return false;
                }
            } while (revealedPixels.has(key));
            
            // 픽셀 위치 기록
            revealedPixels.add(key);
            
            // 2.png의 해당 부분을 캔버스에 그리기
            const sourceX = x * pixelSize;
            const sourceY = y * pixelSize;
            const destX = x * pixelSize;
            const destY = y * pixelSize;
            
            // 렌더링 품질 설정
            ctx.imageSmoothingEnabled = false;
            
            // 페이드인 애니메이션 적용
            let opacity = 0;
            const fadeDuration = 300; // 300ms
            const startTime = performance.now();
            
            function animateFade() {
                const elapsed = performance.now() - startTime;
                opacity = Math.min(elapsed / fadeDuration, 1);
                
                // 기존 영역 지우기
                ctx.clearRect(destX, destY, pixelSize, pixelSize);
                
                // globalAlpha로 페이드인 효과
                ctx.globalAlpha = opacity;
                ctx.drawImage(secondImage, sourceX, sourceY, pixelSize, pixelSize, destX, destY, pixelSize, pixelSize);
                ctx.globalAlpha = 1.0; // 원래대로 복원
                
                if (opacity < 1) {
                    requestAnimationFrame(animateFade);
                }
            }
            
            animateFade();
            
            return true;
        }
        
        // 버튼 클릭 처리
        function handleButtonClick(buttonName) {
            switch(buttonName) {
                case 'button1':
                    revealPixel(); // 2.png의 픽셀 하나 드러내기
                    updateHeartCount(1); // 하트 카운터 증가
                    break;
                case 'button2':
                    // 추가 기능이 필요하면 여기에 구현
                    break;
                case 'button3':
                    // 추가 기능이 필요하면 여기에 구현
                    break;
            }
        }
        
        // 페이지 로드 시 WebSocket 연결
        window.addEventListener('load', function() {
            // 이미지가 이미 로드되어 있을 경우를 대비
            if (imageLoaded) {
                redrawCanvas();
            }
            connectWebSocket();
        });
        
        // 페이지 언로드 시 정리
        window.addEventListener('beforeunload', function() {
            if (ws) {
                ws.close();
            }
        });
    </script>
</body>
</html>
